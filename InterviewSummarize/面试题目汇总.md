# C++ 基础知识
1.静态成员函数能够访问非静态成员变量？
答：静态成员函数只能访问静态成员（构造函数除外）,方式是::限定符,非静态成员函数均可访问。

2.C++的string类实现机制？
答：在 C++ 中,string类是由标准模板库 (STL) 提供的，其底层实现是使用动态数组和指针来存储字符串内容。

3.简单描述C++中的RAII机制？
答：C++ 中的 RAII (Resource Acquisition Is Initialization) 机制是一种基于对象生命周期的资源管理技术。该机制通过将资源的获取和释放与对象的构造和析构相结合，来保证资源在使用结束后一定会被释放。具体来说，在 C++ 中使用 RAII 机制时，我们可以将资源的获取封装在对象的构造函数中，将资源的释放封装在对象的析构函数中。这样，当对象被创建时，它就会自动获取所需的资源；当对象被销毁时，它就会自动释放已占用的资源，从而保证资源的正确管理。

4.std::move的实现机制？
答：C++ 中的std::move函数是一个基于右值引用的移动语义实现函数，其底层机制是通过对原始对象的指针进行类型转换，从而实现对象的高效移动和资源管理。

5.lambda表达式捕获unique_ptr时需要注意什么？
答：
(1)当使用值捕获时，Lambda 表达式会复制 std::unique_ptr 对象，从而创建一个新的独立所有权。这种方式的好处在于，我们可以将该对象传递给其他函数或者 Lambda 表达式，而不用担心资源被误释放。但是，由于 std::unique_ptr 禁止拷贝和赋值操作，因此在值捕获时需要使用 std::move 函数将其移动到 Lambda 表达式中。
(2)当使用引用捕获时，Lambda 表达式会共享 std::unique_ptr 对象，从而使多个代码块都可以访问同一份资源。这种方式的好处在于，可以避免资源的复制和移动，提高代码的性能和效率。但是，需要注意在使用引用捕获时要确保 std::unique_ptr 对象的生命周期足够长，以避免出现悬空指针等问题。

6.const的作用与用法
答：
（1）const与变量组合：定义一个常量，例如，const int a = 5；
（2）const与指针组合，根据const位置不同，含义不同：
a.常量指针->const int* ptr，指针可变，指向的内容不可变；
b.指针常量->int* const ptr，内容可变，指针不可变；
Tip:以*号为界，const位置左侧，标识常量指针，const位置右侧标识指针常量。
（3）const与函数组合，根据位置不同，含义不同：
a.const int func()->返回值不可修改，很少用；
b.int func(const int a)->形参不可修改，一般在形参为引用或指针时使用；
c.int func() const->常成员函数，不可修改成员变量
（4）const和类的组合
a.修饰成员变量，常成员变量
b.修饰成员函数，常成员函数，可支持重载
c.修饰对象或对象引用，常对象/对象常引用，只能访问常成员函数，不能访问非常成员函数，非常对象或常对象应用均可访问。
（5）相对#define宏的优势：
a.有数据类型，编译器会进行类型检查
b.成员函数重载参数
c. const定义常量从汇编的角度来看，只是给出了对应的内存地址，第一次使用时分配，而不是象#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干个拷贝
d. 编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高

7.static用法与作用
（1）修饰局部变量，变量生存期不会随函数调用结束而消失，且只在函数第一次调用时初始化一次。
（2）修饰全局变量，表明变量只能在某个文件中使用。
（3）修饰函数，函数只能在某个文件中调用
（4）修饰类的成员函数，表明还成员变量只会有一个实例对象，该类的所有对象共享此变量，实现数据共享。
（5）修饰成员函数，静态成员函数，类的所以对象共享，可以在对象未实例化时访问，类名::方法，不能直接访问非静态成员变量
（6）静态变量存储在全局数据区
8.new和malloc的区别？
（1）new是c++操作符，可重载，需要编译器支持，malloc是库函数，需要包含头文件
（2）new返回实例类型的指针，malloc返回void*指针
（3）new类对象时会调用构造函数，且无需指明内存大小，malloc需要指明内存大小，不调用构造函数
（4）new分配在自由存储区，自由存储区是c++上抽象出来的存储区，malloc分配在堆上
（5）new/delete，malloc/free
（6）new失败抛出异常，可以delete空指针，malloc失败返回null，free不能释放空指针
（7）new 先调用operator new 再调构造函数，然后返回自定义类型指针，malloc仅申请一段空间，还需要自己初始化内存

9.容器resize和reserve的区别
（1）resize会改变容器的size和capacity，reserve只改变capacity
（2）resize的使用有三种情况：
   a. 参数n < v.size()时，结果是容器v的size减小到n，删除n之后的元素；
   b.v.size() < 参数n < v.capacity()，结果是容器v的size增加到n，增加的元素值初始化为m，m省略时，增加元素值为缺省值，即默认值；
   c.v.capacity() < 参数n，结果是先增大容量capacity至n，然后初始化值，初始化方法与情况2相同，此时v中的size与capacity均发生改变。
（3）reserve的使用情况有两种：
   a.参数n < v.capacity()时，size与capacity均不发生改变；
   b.参数n > v.capacity()时，此时会重新分配一块空间，使得capacity扩容至n，size不发生改变。

10.C++的虚函数的实现机制?
答：
(1)C++实现虚函数的机制是通过虚函数表（Virtual Table）来实现的。每个包含至少一个虚函数的类都有其自己的虚函数表，虚函数表是一张函数指针表，其中存储了该类的所有虚函数的地址。当创建对象时，会在对象中分配一个指向虚函数表的指针vptr，该指针指向虚函数表的地址。当调用虚函数时，实际调用的函数地址就是根据vptr指向的虚函数表中对应的函数指针决定的。
(2)当派生类继承基类的虚函数时，派生类会继承基类的虚函数表，并向其中添加自己的虚函数实现，如果派生类覆盖了基类的虚函数，那么它的函数指针将替代基类指针表中对应的函数指针。

11.单例模式中构造函数为何会可以被静态函数调用？
答：普通非静态函数的调用都需要传入隐藏参数this指针,否则会出现编译报错,但构造函数调用时还不存在this指针,也不需要传入this指针，故可以调用。

12.饿汉单例模式为何可以在类外调用私有的构造函数？
答：静态变量初始化时,会用类的作用域范作为限定,在类作用域范围类,是可以调用私有构造函数的。

13.c++中容器set和map的底层实现？
(1)C++中的容器set和map底层均是基于红黑树实现的。
(2)红黑树是一种自平衡二叉树，具有以下特性：
    a.每个节点要么是红色，要么是黑色；
    b.根节点是黑色的；
    c.所有叶子节点（NULL节点）是黑色的；
    d.如果一个节点是红色的，则它的两个子节点都是黑色的；
    e.从任意一个节点到其每个叶子节点的所有路径都包含相同数目的黑色节点。
    f.在插入或删除元素时，红黑树会通过旋转、颜色翻转等操作保持平衡，以保证查询的时间复杂度始终为O(log(n))。

14.抽象类中是否需要定义析构函数？
答：
(1)当抽象类作为基类时,需要将析构函数定义为虚函数;
(2)也可以定义为纯虚析构函数也必须给出实现,其原因在于对象析构时会从派生类的析构函数依次调用。

15.什么是虚函数？什么是纯虚函数？
答：
(1)虚函数是允许被子类重新定义的成员函数,是实现运行时多态的核心；
(2)纯虚函数（Pure Virtual Function）是一个在基类中定义的没有实现的虚函数（Virtual Function）,形如virtual void fun() = 0，它只有函数原型，没有函数体,仅在派生类中实现。

16.基类为什么需要虚析构函数？
答:防止内存泄漏。当借用父类指针去析构子类对象时，若析构函数不是虚函数，则只会调用到父类的析构函数，那么子类中申请的资源将无法释放。

17.c++的强制转换？
答:
(1)隐式转换
a.基础类型,如：int a = int(1.2);
b.自定义类型,如:单参构造函数的隐式转换
(2)显示转换
a.static_cast：
(1)主要用于内置数据类型之间的相互转换;
(2)也可以转换自定义类型。如果涉及到类，static_cast只能在有相互联系（继承）的类型间进行转换，且不一定包含虚函数.
b.const_cast：去const化.
c.dynamic_cast：
    (1)dynamic_cast是运行时处理的，运行时要进行类型检查;
    (2)不能用于内置基本数据类型间的强制转换;
    (3)使用dynamic_cast进行转换时，基类中一定要有虚函数，否则编译不通过。类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的必要，此时转换才有意义;
    (4)dynamic_cast转换若成功，返回的是指向类的指针或引用；若失败则会返回NULL;
    (5)在类的转换时，在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的。
        a.在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。向上转换即为指向子类对象的向上转换，即将子类指针转化父类指针。
        b.向下转换的成败取决于将要转换的类型，即要强制转换的指针所指向的对象实际类型与将要转换后的类型一定要相同，否则转换失败。
d.reinterpret_cast:它可以转化任何内置的数据类型为其他任何的数据类型，也可以转化任何指针类型为其他的类型。

18.指针和引用的区别？
答：
(1).指针是变量,保存地址;引用是别名,本质还是变量本身.
(2).可以有指针常量(int* const ptr),但没有引用常量(int& const a).
(3).指针可以有多级，但是引用只能是一级;
(4).指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化;
(5).指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了;
(6)."sizeof引用"得到的是所指向的变量(对象)的大小，而"sizeof指针"得到的是指针本身的大小;
(7).指针和引用的自增(++)运算意义不一样,指针++表示指向下个位置，引用则表示变量自增；
(8).指针使用时需要解引用（*），引用则不需要.

19.vector、map、multimap、unordered_map、unordered_multimap的底层数据结构，以及几种map容器如何选择?
答：
(1).vector基于数组，map、multimap基于红黑树，unordered_map、unordered_multimap基于哈希表。
(2).a.map/unordered_map 不允许重复元素
    b.multimap/unordered_multimap 允许重复元素
    c.map/multimap 底层基于红黑树，元素自动有序，且插入、删除效率高
    d.unordered_map/unordered_multimap 底层基于哈希表，故元素无序，查找效率高。

20.什么是哈希表？什么是红黑树？
答：
(1).红黑树：红黑树是一种自平衡二叉查找树，它具有以下特点：
    a.每个节点都是红色或黑色。
    b.根节点是黑色的。
    c.叶子节点（NULL节点）都是黑色的。
    d.如果一个节点是红色的，则它的子节点必须是黑色的。
    d.从任意一个节点到其每个叶子节点的所有路径都包含相同数目的黑色节点。
    这些规则保证了红黑树相对平衡，因此在最坏情况下，查找、插入和删除操作的时间复杂度仅为O(log n)。
(2).哈希表：也叫散列表，是一种数据结构，它提供了快速的插入操作和查找操作。无论哈希表中有多少条数据，插入和查找的时间复杂度都是为O(1)。哈希表的查找速度非常快，所以在很多程序中都有使用哈希表，例如拼音检查器。哈希表使用哈希函数将键映射到存储桶或槽位中，从而可以快速的定位到相应的值。哈希表需要解决哈希冲突问题。

21.什么是原子操作？
答: (1)原子操作理解为：不需要用到互斥量加锁（无锁）技术的多线程并发编程方式，并且原子操作在多线程中不会被打断执行；        
    (2)原子操作比互斥量在效率上更高；
    (3)互斥量的加锁一般是针对一个代码段(几行代码), 原子操作针对的都是一个变量，而不是针对一个代码段；
    (4)原子操作：该变量要么完成，要么没完成，不存在中间状态。
    (5)原子性不可能由软件单独保证--必须需要硬件的支持，因此是和架构相关的。
    (6)原子操作常用的做法是给总线上锁(bus lock)，以获得在一定的时间窗口内对总线独占的授权

22.自选锁和互斥锁区别？
答: (1)互斥锁触发时,进程被挂起,不占用CPU资源;自旋锁会占用cpu资源;
    (2)互斥锁是独占锁，开销大;自旋锁是轻量锁,开销小;

# 操作系统知识
1.进程间通信方式有哪些？
答：
(1)管道（Pipe）
管道是一种半双工的进程间通信机制，可以在两个相关进程之间传递数据。它一般分为有名管道和无名管道，其中有名管道可以在不同进程之间传递数据，而无名管道只能在父子进程之间传递数据。
(2)消息队列（Message Queue）
消息队列是一种进程间通信机制，可以将数据以消息的形式传递给其他进程。其中，发送进程将数据写入到消息队列，而接收进程则从消息队列中读取数据，并根据消息类型进行相应的处理。它主要用于进程间异步通信和解耦合。
(3)共享内存（Shared Memory）
共享内存是一种可供多个进程共享的内存区域，在该区域内的数据对所有进程都可见。其特点是高效、快速，适合大量数据的共享和频繁的通信操作。
(4)信号量（Semaphore）
信号量是一种用于控制并发访问的工具，可用于避免进程竞争和资源争用。通过使用信号量，进程可以互斥地访问共享资源，从而避免数据冲突和其他竞态条件。
(5)套接字（Socket）
套接字是一种用于网络通信的机制，可以在不同计算机之间进行远程数据传输。其特点是灵活、可靠，适合用于跨机器进程间通信和分布式系统的实现。

2.linux怎么查找并替换一段字符？
答：在Linux系统中，可以使用sed命令查找并替换一段字符。sed是一种流编辑器，可以对文本进行替换、删除、插入等操作。

3.GDB常用命令？
GDB是一个强大的命令行调试工具，可以用于Linux系统和其他操作系统的程序调试。以下是常用的GDB命令：
运行命令
run：简记为 r，运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。
start：启动程序，并暂停在main函数的第一行处等待调试命令。
断点命令
break：简记为 b，在指定的代码行设置断点，例如 b 10 在第10行设置断点。
delete：删除指定编号或所有断点。
disable：禁用指定编号或所有断点。
单步执行命令
next：简写 n，单步执行当前行，不进入子函数。
step：简写 s，单步执行当前行，进入子函数。
finish：执行完当前子函数并返回到父函数。
变量显示和修改命令
print：简写 p，显示变量的值。
set：修改变量的值。
display：每次停在断点时都显示一个或多个表达式的值。
程序状态查询命令
info：查询程序中的各种信息，例如 info breakpoints 显示当前所有断点的信息，info locals 显示当前函数的本地变量。
finish：执行完当前子函数并返回到父函数。
GDB调试控制命令
quit：简写为 q，退出GDB调试器。
help：显示GDB的帮助信息。
list：简写为 l，显示当前代码的上下文（10行）。
backtrack：简写为bt,查看当前调用栈。

4.不同进程如何保证内存隔离？
答: (1)操作系统会给每一个进程维护一个页表，并保证在执行进程A的时候使用A的页表，执行进程B的时候使用B的页表。
    (2)页表是由操作系统维护的，页表存在于内核内存中，进程访问不了内核内存。

5.共享内存是如何实现的？
答:申请,挂接,去挂接,释放

# TCP/IP面试题目
1.基础概念？
答:SYN:请求建立连接,FIN:请求断开连接,ACK:确认标记位,seq:序列号,ack:确认号。

2.什么是3次握手？  
答: (1)第一次握手:客户端向服务端发送请求建立连接报文,报文中同步位SYN=1,序列号seq=x,不携带数据,客户端处于同步发送态;  
    (2)第二次握手:服务端接收请求报文后向客户端发送确认报文,报文中确认位ACK=1和同步位SYN=1,确认号ack=x+1,序列号seq=y,表示服务端可以建立连接,不携带数据,服务端处于同步接收态;
    (3)第三次握手:客户端收到确认报文后,首先检查ACK=1,ack=x+1,若是则发送确认报文,报文中ACK=1,ack=y+1,seq=x+1,并进入建立态,服务端收到后检查ACK=1,ack=y+1,若是则代表建立成功,服务端也进入建立态,两者相互传递数据。

3.什么是4次挥手？
答: (1)第一次挥手:客户端向服务端发送FIN=1(请求断开连接),并生成序列号seq=x,进入wait_1;
    (2)第二次挥手:服务端收到后,向客户端发送ACK=1,并将ack=x+1(客户端无数据发送,但服务器端需发送完最后的数据),客户端收到后进入wait_2状态;
    (3)第三次挥手:服务端向客户端发送FIN=1和ACK=1,并将ack=x+1,同时生成自己的序列号seq=y,表示服务点可以断开连接,进入last_ack态;
    (4)客户端收到后,向服务端发送ACK=1,并将ack=y+1,以及自己seq=x+1,进入time_wait态,等待2msl,未收到服务端ACK信号,认为服务端已关闭,于是自己也关闭连接。

4.为什么需要3次握手？
答: (1)因为如果客户端第一次发送的SYN报文因为网络问题而迟迟没有到达服务端,此时客户端会因为超时而重新发送一个新的SYN报文,此时上一个SYN报文在客户端就会失效,如果这里只采用两次握手,会因为客户端第二次发送SYN后,第一次发送的SYN又成功到达服务端,这时就会建立两个连接,产生问题。
    (2)如果采用的是三次握手,就算是那一次失效的报文传送过来了,服务端接受到了那条失效报文并且回复了确认报文,但是客户端不会再次发出确认,由于服务器收不到确认,就知道客户端并没有请求连接。

5.为什么连接的时候是三次握手,关闭的时候却是四次握手？
答:因为当Server端收到Client端的SYN连接请求报文后,可以直接发送SYN+ACK报文,其中ACK报文是用来应答的,SYN报文是用来同步的。但是关闭连接时,当Server端收到FIN报文时,很可能并不会立即关闭(可能还有一些数据没处理),所以只能先回复一个ACK报文,告诉Client端,"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了,我才能发送FIN报文,因此服务端需要回复2次(挥手2次),故需要四次挥手。

6.为什么需要经过2MSL(报文段在网络中最大生存时间)才能返回到CLOSE状态？
答: (1)1个MSL保证四次挥手中主动关闭方最后的ACK报文能最终到达对端;
    (2)1个MSL保证对端没有收到ACK那么进行重传的FIN报文能够到达。

7.TCP和UDP的区别？
答: (1)TCP面向连接;UDP是无连接的,即发送数据之前不需要建立连接;
    (2)TCP要求安全性,提供可靠的服务,通过TCP连接传送的数据,不丢失、不重复、安全可靠;而UDP尽最大努力交付,即不保证可靠交付;
    (3)TCP是点对点连接的;UDP一对一、一对多、多对多都可以;
    (4)TCP传输效率相对较低,而UDP传输效率高,它适用于对高速传输和实时性有较高的通信或广播通信;
    (5)TCP适合用于网页,邮件等;UDP适合用于视频，语音广播等;
    (6)TCP面向字节流,UDP面向报文。

8.socket与tcp/ip关系？
答:在网络编程中,Socket通常用于实现基于TCP/IP协议的网络通信,Socket API提供了与TCP相关的函数和接口,使得开发者能够通过Socket实现基于TCP协议的网络通信。

9.什么是TCP/IP协议？
答: (1)TCP/IP协议是Internet上最常用的网络通信协议之一,是指传输控制协议(TCP)和网络互联协议(IP)的组合。它是一种开放的、分层的协议体系结构,包括网络接口层(物理层、数据链路层)、网络层、传输层和应用层等4个层次。
    (2)IP协议负责在整个互联网中进行数据通信的管理和路由选择;而TCP协议则负责在端对端的通信中,对数据的可靠传输进行控制和管理。TCP/IP协议可以通过这两个协议提供可靠的、无差错的数据传输服务，并且具有较好的扩展性和兼容性。
    (3)在TCP/IP协议中,每个层次都有自己的功能和服务,下层服务为上层提供支持和服务。在应用程序中，可以通过Socket API来使用TCP/IP协议实现网络通信。
    (4)总之,TCP/IP协议是一种分层的互联网通信协议,它由两个主要的协议TCP和IP组成,可以提供可靠的、无差错的数据传输服务,并且可以实现高度的扩展性和兼容性。

10.TCP报文首部有哪些字段,说说其作用?
答: |          16为源端口号            |            16位目的端口号            |
    |                              32位序号                                  |
    |                              32确认号                                  |
    |4位头部长度|6位保留|URG|ACK|PSH|RST|SYN|FIN|    16位窗口大小              |
    |         16为校验和               |            16位紧急指针              |
    (1)16位端口号:源端口号,主机该报文段是来自哪里;目标端口号,要传给哪个上层协议或应用程序;
    (2)32位序号:一次TCP通信（从TCP连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号;
    (3)32位确认号:用作对另一方发送的tcp报文段的响应,其值是收到的TCP报文段的序号值加1;
    (4)4位头部长度:表示tcp头部有多少个32bit字(4字节),因为4位最大能标识15,所以TCP头部最长是60 = 4*15字节;
    (5)6位标志位:URG(紧急指针是否有效),ACK(表示确认号是否有效),PSH(缓冲区尚未填满),RST(表示要求对方重新建立连接),SYN(建立连接消息标志接),FIN(表示告知对方本端要关闭连接);
    (6)16位窗口大小:是TCP流量控制的一个手段。这里说的窗口指的是接收通告窗口,它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据,这样对方就可以控制发送数据的速度。
    (7)16位校验和:由发送端填充,接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。(注意:这个校验不仅包括TCP头部，也包括数据部分),这也是TCP可靠传输的一个重要保障。
    (8)16位紧急指针:一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此,确切地说,这个字段是紧急指针相对当前序号的偏移,不妨称之为紧急偏移。TCP的紧急指针是发送端向接收端发送紧急数据的方法。

11.TCP是如何保证可靠性的?
答: (1)TCP的连接是基于三次握手,而断开则是四次挥手,确保连接和断开的可靠性。
    (2)TCP会记录哪些数据发送了,哪些数据被接收了,哪些没有被接收,并且保证数据包按序到达,保证数据传输不出差错。
    (3)TCP的可靠性,还体现在可控制。它有报文校验、ACK应答、超时重传(发送方)、失序数据重传（接收方）、丢弃重复数据、流量控制（滑动窗口）和拥塞控制等机制。

12.TCP的超时重传？
答: (1)TCP为了实现可靠传输,实现了重传机制。最基本的重传机制,就是超时重传,即在发送数据报文时,设定一个定时器,每间隔一段时间,没有收到对方的ACK确认应答报文,就会重发该报文。RTO:J/K算法获取,RTT数据往返1次的时间。
    (2)缺点: a.当一个报文段丢失时,会等待一定的超时周期然后才重传,增加了端到端的时延。
             b.当一个报文段丢失时,在其等待超时的过程中,可能会出现这种情况:其后的报文段已经被接收端接收但却迟迟得不到确认,发送端会认为也丢失了,从而引起不必要的重传,既浪费资源也浪费时间。

13.快速重传？
答: (1)快速重传机制不以时间驱动,而是以数据驱动,它基于接收端的反馈信息来引发重传。(接收到三个重复的ack,则需要重传)
    (2)ACK只向发送端告知最大的有序报文段,到底是哪个报文丢失了呢？并不确定！

14.带选择确认的重传(SACK)?
答:SACK机制就是,在快速重传的基础上,接收端返回最近收到的报文段的序列号范围,这样发送端就知道接收端哪些数据包没收到,这样就很清楚该重传哪些数据包啦。SACK标记是加在TCP头部选项字段里面的。

15.什么是D-SACK？
答: D-SACK即Duplicate SACK(重复SACK),在SACK的基础上做了一些扩展,主要用来告诉发送方有哪些数据包自己重复接受了。DSACK的目的是帮助发送方判断是否发生了包失序、ACK丢失、包重复或伪重传。让TCP可以更好的做网络流控。

16.TCP的滑动窗口?
答: (1)TCP 发送一个数据,需要收到确认应答才会发送下一个数据。这样有个缺点就是效率会比较低。
    (2)为了解决这个问题TCP引入了窗口，它是操作系统开辟的一个缓存空间。窗口大小值表示无需等待确认应答而可以继续发送数据的最大值。
    (3)TCP头部有个字段叫win也即那个16位的窗口大小,它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据,这样对方就可以控制发送数据的速度,从而达到流量控制的目的。
    详细来说：
    (1)发送端的滑动窗口:发送缓存,起:第一个已发送为确认数据,止:未发送但可以发送数据。
    a.已发送且已收到ACK确认
    b.已发送但未收到ACK确认
    c.未发送但可以发送
    d.未发送也不可以发送
    (2)接收端的滑动窗口:接收缓存,起:未接收但可接收的第1个数据,止:未接收但可接收的last数据.
    a.已成功接收并确认
    b.未收到数据但可以接收
    c.未收到数据并不可以接收的数据

17.TCP的流量控制？
答: TCP 提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量,这就是流量控制.
    (1)假如当前发送方给接收方发送了200个字节,那么发送方的SND.NXT会右移200个字节,也就是说当前的可用窗口减少了200 个字节。
    (2)接受方收到后放到缓冲队列里面,REV.WND =400-200=200字节,所以win=200字节返回给发送方。接收方会在 ACK 的报文首部带上缩小后的滑动窗口200字节
    (3)发送方又发送200字节过来,200字节到达，继续放到缓冲队列。不过这时候由于大量负载的原因,接受方处理不了这么多字节,只能处理100字节,剩余的100字节继续放到缓冲队列。这时候，REV.WND = 400-200-100=100字节,即win=100返回发送方。
    (4)发送方继续干活发送100字节过来,这时候接受窗口win变为0。
    (5)发送方停止发送,开启一个定时任务,每隔一段时间,就去询问接受方,直到win大于0才继续开始发送。

18.TCP的拥塞控制?
答: (1)拥塞控制是作用于网络的,防止过多的数据包注入到网络中避免出现网络负载过大的情况。它的目标主要是最大化利用网络上瓶颈链路的带宽。它跟流量控制的区别在于流量控制是作用于接收者的,根据接收端的实际接收能力控制发送速度,防止分组丢失的。
    (2)发送方维护一个拥塞窗口cwnd（congestion window） 的变量,用来估算在一段时间内这条链路可以承载和运输的数据的数量。
    (3)只要网络中没有出现拥塞,拥塞窗口的值就可以再增大一些,以便把更多的数据包发送出去,但只要网络出现拥塞,拥塞窗口的值就应该减小一些,以减少注入到网络中的数据包数.
    (4)拥塞控制主要有这几种常用算法:
        a.慢启动算法:
            (1)它表示TCP建立连接完成后一开始不要发送大量的数据,而是先探测一下网络的拥塞程度。由小到大逐渐增加拥塞窗口的大小,如果没有出现丢包,每收到一个ACK,就将拥塞窗口cwnd大小就加1（单位是MSS）。每轮次发送窗口增加一倍,呈指数增长,如果出现丢包,拥塞窗口就减半,进入拥塞避免阶段。
            (2)为了防止cwnd增长过大引起网络拥塞,还需设置一个慢启动阀值ssthresh（slow start threshold）状态变量。当cwnd到达该阀值后,就好像水管被关小了水龙头一样,减少拥塞状态。即当cwnd >ssthresh时，进入了拥塞避免算法。
                a.TCP连接完成初始化cwnd = 1,表明可以传一个MSS单位大小的数据。
                b.每当收到一个ACK,cwnd就加一;
                c.每当过了一个RTT,cwnd就增加一倍, 呈指数让升
        b.拥塞避免算法:这是一个线性上升的算法，避免过快导致网络拥塞问题。
            (1)每收到一个ACK时:cwnd = cwnd + 1/cwnd
            (2)当每过一个RTT时:cwnd = cwnd + 1
        c.拥塞发生:当网络拥塞发生丢包时会有两种情况:
            (1)RTO超时重传:
                a.慢启动阀值sshthresh = cwnd /2
                b.cwnd 重置为 1
                c.进入新的慢启动过程
            (2)快速重传
                a.拥塞窗口大小 cwnd = cwnd/2
                b.慢启动阀值 ssthresh = cwnd
                c.进入快速恢复算法
        d.快速恢复：
            (1)cwnd = sshthresh + 3
            (2)重传重复的那几个ACK（即丢失的那几个数据包）
            (3)如果再收到重复的 ACK,那么 cwnd = cwnd +1
            (4)如果收到新数据的 ACK 后, cwnd = sshthresh。因为收到新数据的 ACK,表明恢复过程已经结束,可以再次进入了拥塞避免的算法了。

19.半连接队列和 SYN Flood 攻击的关系?
答: (1)TCP三次握手时,客户端发送SYN到服务端,服务端收到之后,便回复ACK和SYN,状态由LISTEN变为SYN_RCVD,此时这个连接就被推入了SYN队列,即半连接队列;
    (2)当客户端回复ACK, 服务端接收后,三次握手就完成了。这时连接会等待被具体的应用取走,在被取走之前,它被推入ACCEPT队列,即全连接队列。
    (3)SYN Flood是一种典型的DoS (Denial of Service，拒绝服务) 攻击,它在短时间内伪造不存在的IP地址,向服务器大量发起SYN报文。当服务器回复SYN+ACK报文后,不会收到ACK回应报文,导致服务器上建立大量的半连接半连接队列满了,这就无法处理正常的TCP请求啦。
    (4)应对方案:
        a.syn cookie:在收到SYN包后，服务器根据一定的方法,以数据包的源地址、端口等信息为参数计算出一个cookie值作为自己的SYNACK包的序列号,回复SYN+ACK后,服务器并不立即分配资源进行处理,等收到发送方的ACK包后,重新根据数据包的源地址、端口计算该包中的确认序列号是否正确，如果正确则建立连接,否则丢弃该包。
        b.SYN Proxy防火墙:服务器防火墙会对收到的每一个SYN报文进行代理和回应,并保持半连接。等发送方将ACK包返回后,再重新构造SYN包发到服务器，建立真正的TCP连接。

20.Nagle 算法与延迟确认
答: (1)Nagle算法就是为了尽可能发送大块数据,避免网络中充斥着许多小数据块,具体规则：
        a.如果包长度达到MSS,则允许发送；
        b.如果该包含有FIN,则允许发送；
        c.设置了TCP_NODELAY选项,则允许发送；
        d.未设置TCP_CORK选项时,若所有发出去的小数据包（包长度小于MSS）均被确认,则允许发送；
        e.上述条件都未满足但发生了超时(一般为200ms),则立即发送。
    (2)延迟确认:接收方收到数据包后,如果暂时没有数据要发给对端,它可以等一段时再确认（Linux上默认是40ms）。如果这段时间刚好有数据要传给对端,ACK就随着数据传输,而不需要单独发送一次ACK。如果超过时间还没有数据要发送,也发送ACK,避免对端以为丢包。
    (3)Nagle算法和延迟确认不能一起使用，Nagle算法意味着延迟发，延迟确认意味着延迟接收，酱紫就会造成更大的延迟，会产生性能问题。
21.TCP的粘包和拆包?
答: (1)一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。
    (2)为什么会产生粘包和拆包呢?
        a.要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包；
        b.接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；
        c.要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包；
        d.待发送数据大于MSS(最大报文长度),TCP在传输前将进行拆包。即TCP报文长度-TCP头部长度>MSS。
    (3)解决方案：
        a.送端将每个数据包封装为固定长度
        b.在数据尾部增加特殊字符进行分割
        c.将数据分为两部分,一部分是头部,一部分是内容体;其中头部结构大小固定,且有一个字段声明内容体的大小。

22.TCP/IP四层模型？
答:tcp/ip 四层模型:从上到下依次是应用层,传输层,网络层,网络接口层（数据链路层）
    a.应用层:
        (1)为用户的应用进程提供服务;
        (2)协议:Telnet,FTP,SMTP,HTTP,DNS,SSH(加密)等
    b.传输:
        (1)负责向两个主机中进程之间的通信提供通用的数据传输服务;
        (2)输层并不负责将数据从一个设备传输到另一个设备,这是网络层的任务;
        (3)协议:TCP/UDP
    c.网络层:
        (1)负责为分组交换网上的不同主机提供通信服务;
        (2)选择合适的路由，使源主机运输层传下来的分组，能够通过网络中的路由找到目的主机;
        (3)协议:IP,ARP,RARP,ICMP
    d.网络接口层:
        (1)数据链路层将网络层交下来的IP数据报加上MAC头部封装成帧,在两个相邻计算机节点之间的链路上传送帧。每一帧都包括数据和必要的控制信息(如同步信息、地址信息、差错控制等);
        (2)物理层是用来实现相邻计算机节点之间比特流的透明传送,尽可能屏蔽掉具体传输介质和物理设备的差异;

23.IP协议？
答: (1)寻址:在寻址过程中,先匹配到相同的网络号(表示要找到同一子网),才会去找对应的主机。
    (2)路由:寻找转发路径。